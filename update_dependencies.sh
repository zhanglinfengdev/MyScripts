#!/bin/bash

# --- Configuration ---
# Input file generated by the previous script
DEPENDENCY_INPUT_FILE="generated_dependencies.properties"
# Default dependency type (e.g., implementation, api, testImplementation)
DEPENDENCY_TYPE="implementation"
# Gradle task to run after updating dependencies
GRADLE_TASK="assembleDebug"

# --- Function: Print Usage ---
usage() {
  echo "用法: $0 <path_to_target_app_build_gradle_or_kts>"
  echo ""
  echo "这个脚本会读取 '$DEPENDENCY_INPUT_FILE' 文件中的依赖信息,"
  echo "将它们格式化为 '$DEPENDENCY_TYPE' 类型的依赖项,"
  echo "并插入到指定的目标 app build 文件 (build.gradle 或 build.gradle.kts)"
  echo "的 dependencies { ... } 块的末尾。"
  echo "最后，在目标 app 目录下运行 './gradlew $GRADLE_TASK'。"
  echo ""
  echo "示例: $0 /path/to/your/app/build.gradle"
  exit 1
}

# --- Function: Print Error and Exit ---
error_exit() {
  echo "错误: $1" >&2
  # Try to change back to original directory if possible before exiting
  if [ -n "$ORIGINAL_DIR" ] && [ "$(pwd)" != "$ORIGINAL_DIR" ]; then
      cd "$ORIGINAL_DIR" || echo "警告: 无法切换回原始目录 '$ORIGINAL_DIR'" >&2
  fi
  exit 1
}

# --- Function: Insert Dependency Line ---
# $1: Full dependency line (e.g., "implementation 'group:artifact:version'")
# $2: Path to the target build file
insert_dependency() {
    local new_dep_line="$1"
    local build_file="$2"
    # Create a secure temporary file
    local temp_file
    temp_file=$(mktemp) || error_exit "无法创建临时文件。"
    # Ensure temp file is removed on script exit or error
    trap 'rm -f "$temp_file"' EXIT

    echo "  正在注入依赖到 '$build_file': $new_dep_line"

    # awk script:
    # -v new_dep: Pass the dependency line to awk (with indentation)
    # Logic: Find 'dependencies {', set a flag. When flag is set and '}' is found
    # AND the brace nesting level returns to 0, print the new dependency *before*
    # printing the '}'. This handles nested braces within the dependencies block.
    awk -v new_dep="    $new_dep_line" '
    BEGIN { in_deps = 0; brace_level = 0; inserted = 0; }
    # Match start, handle potential whitespace and comments before '{'
    /^[ \t]*dependencies[ \t]*\{/ {
        if (brace_level == 0) { # Only trigger on top-level dependencies block
            in_deps = 1;
            # printf("DEBUG: Entered dependencies block at line %d\n", FNR) > "/dev/stderr"; # Debugging
        }
        print $0; # Print the 'dependencies {' line
        # Count all braces on this line to handle cases like dependencies { implementation ... }
        current_line_braces = gsub(/{/, "{") - gsub(/}/, "}");
        brace_level += current_line_braces;
        next;
    }
    # If inside dependencies block, track brace levels
    in_deps {
        # Count braces on the current line
        current_line_braces = gsub(/{/, "{") - gsub(/}/, "}");
        # Look for the closing brace of the block BEFORE decrementing
        # This handles single-line blocks correctly and finds the right spot
        if (brace_level + current_line_braces == 0 && match($0, /}/)) {
            # printf("DEBUG: Found closing brace at line %d, brace_level=%d, current_line_braces=%d\n", FNR, brace_level, current_line_braces) > "/dev/stderr"; # Debugging
            if (!inserted) { # Ensure insertion happens only once per file pass
                 print new_dep; # Print the new dependency *before* the closing brace line
                 inserted = 1;
            }
            in_deps = 0; # We are now effectively outside the block for insertion purposes
        }
        # Update brace level *after* checking the closing condition
        brace_level += current_line_braces;
    }
    # Default action: print the current line
    { print $0 }
    ' "$build_file" > "$temp_file"

    # Check awk exit status
    if [ $? -ne 0 ]; then
        error_exit "awk 处理 '$build_file' 失败。"
    fi

    # Check if insertion happened (basic check: temp file size > original)
    # This isn't foolproof but better than nothing. A more robust check is hard.
    original_size=$(wc -c <"$build_file")
    new_size=$(wc -c <"$temp_file")
    if [ "$new_size" -le "$original_size" ]; then
         echo "警告: awk 似乎没有成功将依赖项插入 '$build_file'。可能是 dependencies 块未找到或格式不兼容。" >&2
         # Optionally, treat this as an error: return 1
    fi

    # Replace original file
    mv "$temp_file" "$build_file"
    if [ $? -ne 0 ]; then
        error_exit "无法用更新后的版本覆盖 '$build_file'。"
    fi

    echo "  成功更新 '$build_file'."
    # Release trap for this specific temp file as it's been moved
    trap - EXIT
    return 0
}


# --- Main Script Logic ---

ORIGINAL_DIR=$(pwd)

# 1. Check Arguments
if [ $# -ne 1 ]; then
  echo "错误: 需要提供目标 app build 文件的路径作为参数。" >&2
  usage
fi
TARGET_BUILD_FILE="$1"

# 2. Validate Input Files
if [ ! -f "$DEPENDENCY_INPUT_FILE" ]; then
  error_exit "输入依赖文件 '$DEPENDENCY_INPUT_FILE' 未找到。"
fi
if [ ! -f "$TARGET_BUILD_FILE" ]; then
  error_exit "目标 build 文件 '$TARGET_BUILD_FILE' 未找到。"
fi

TARGET_APP_DIR=$(dirname "$TARGET_BUILD_FILE")
if [ ! -d "$TARGET_APP_DIR" ]; then
    error_exit "无法从 '$TARGET_BUILD_FILE' 推断出有效的应用目录。"
fi


echo "开始更新依赖项..."
echo "输入文件: $DEPENDENCY_INPUT_FILE"
echo "目标文件: $TARGET_BUILD_FILE"
echo "应用目录: $TARGET_APP_DIR"
echo "依赖类型: $DEPENDENCY_TYPE"

# 3. Read Input File and Inject Dependencies
current_group=""
current_artifact=""
current_version=""
processed_count=0
dependencies_to_add=() # Array to hold dependency strings

while IFS= read -r line || [ -n "$line" ]; do # Process last line if no newline
    # Trim whitespace (optional but good) and skip comments
    line=$(echo "$line" | xargs)
    if [[ "$line" == \#* ]]; then continue; fi

    # Extract Key-Value
    key="${line%%=*}"
    value="${line#*=}"

    # Assign values based on key
    if [[ "$key" == "GROUP" ]]; then current_group="$value";
    elif [[ "$key" == "ARTIFACT_ID" ]]; then current_artifact="$value";
    elif [[ "$key" == "VERSION_NAME" ]]; then current_version="$value";
    fi

    # If line is empty OR we are at the end (checked by loop condition), process block
    is_separator=false
    if [[ -z "$line" ]]; then
        is_separator=true
    fi

    if ($is_separator || ! IFS= read -r) && [ -n "$current_group" ] && [ -n "$current_artifact" ] && [ -n "$current_version" ]; then
        echo "解析块: G=$current_group, A=$current_artifact, V=$current_version"
        # Format the dependency string
        dependency_string="$DEPENDENCY_TYPE '$current_group:$current_artifact:$current_version'"
        # Add to array for later insertion
        dependencies_to_add+=("$dependency_string")
        processed_count=$((processed_count + 1))
        # Reset for next block
        current_group=""
        current_artifact=""
        current_version=""
    elif $is_separator; then
         # Reset even if block wasn't complete
        current_group=""
        current_artifact=""
        current_version=""
    fi

done < "$DEPENDENCY_INPUT_FILE"

# Check if any dependencies were found
if [ ${#dependencies_to_add[@]} -eq 0 ]; then
    echo "警告: 在 '$DEPENDENCY_INPUT_FILE' 中未找到有效的依赖块。"
    echo "未修改 '$TARGET_BUILD_FILE'。跳过 Gradle 构建。"
    exit 0 # Exit cleanly, nothing to do
fi

echo "找到 ${#dependencies_to_add[@]} 个依赖项需要添加到 '$TARGET_BUILD_FILE'。"

# Inject all found dependencies one by one
# Doing it sequentially ensures they appear in the order found in the input file
# and reduces complexity compared to one massive awk call.
for dep in "${dependencies_to_add[@]}"; do
    insert_dependency "$dep" "$TARGET_BUILD_FILE"
    # insert_dependency function handles errors and exits if necessary
done

echo "所有依赖项已成功注入 '$TARGET_BUILD_FILE'。"


# 4. Run Gradle assembleDebug Task
echo "切换到目标应用目录: $TARGET_APP_DIR"
cd "$TARGET_APP_DIR" || error_exit "无法切换到目录 '$TARGET_APP_DIR'"

# Determine Gradle command (Assuming wrapper for now)
gradle_command="./gradlew"
info_msg "$config_name" "将使用的 Gradle 命令来源: Wrapper ($gradle_command)" # Placeholder config_name

# Check wrapper exists and is executable
if [ ! -x "$gradle_command" ]; then
    echo "警告: '$gradle_command' 在 '$TARGET_APP_DIR' 中不存在或不可执行。尝试添加权限..."
    chmod +x "$gradle_command"
    if [ $? -ne 0 ]; then
         error_exit "无法为 '$gradle_command' 添加执行权限。"
         # error_exit handles cd back if needed
    fi
fi

echo "正在运行 Gradle 任务: $gradle_command $GRADLE_TASK"
"$gradle_command" "$GRADLE_TASK"
ASSEMBLE_EXIT_CODE=$?

# 5. Return to original directory and report status
echo "切换回原始目录: $ORIGINAL_DIR"
cd "$ORIGINAL_DIR" || echo "警告: 无法切换回原始目录 '$ORIGINAL_DIR'" >&2

if [ $ASSEMBLE_EXIT_CODE -ne 0 ]; then
     error_exit "Gradle 任务 '$GRADLE_TASK' 失败，退出码: $ASSEMBLE_EXIT_CODE。"
fi

echo "Gradle 任务 '$GRADLE_TASK' 成功完成。"
echo "依赖更新脚本执行完毕！"
exit 0
