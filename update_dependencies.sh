#!/bin/zsh

# export JAVA_HOME=/usr/local/Cellar/openjdk@11/11.0.25/libexec/openjdk.jdk/Contents/Home
# export JAVA_HOME=/Users/didi/Library/Java/JavaVirtualMachines/corretto-15.0.2/Contents/Home
export JAVA_HOME=/Users/didi/Library/Java/JavaVirtualMachines/corretto-17.0.14/Contents/Home

# --- Configuration ---
# Input file generated by the previous script
DEPENDENCY_INPUT_FILE="/Users/didi/generated_dependencies.properties"
# Default dependency type (e.g., implementation, api, testImplementation)
DEPENDENCY_TYPE="implementation"
# Gradle task to run after updating dependencies
GRADLE_TASK="assembleDebug"

info_msg() { echo "INFO: $1"; }
error_msg() { echo "ERROR: $1" >&2; }
# --- Function: Print Usage ---
usage() {
  echo "用法: $0 <path_to_target_app_build_gradle_or_kts>"
  echo ""
  echo "这个脚本会读取 '$DEPENDENCY_INPUT_FILE' 文件中的依赖信息,"
  echo "将它们格式化为 '$DEPENDENCY_TYPE' 类型的依赖项,"
  echo "并插入到指定的目标 app build 文件 (build.gradle 或 build.gradle.kts)"
  echo "的 dependencies { ... } 块的末尾。"
  echo "最后，在目标 app 目录下运行 './gradlew $GRADLE_TASK'。"
  echo ""
  echo "示例: $0 /path/to/your/app/build.gradle"
  exit 1
}

# --- Function: Print Error and Exit ---
error_exit() {
  echo "错误: $1" >&2
  # Try to change back to original directory if possible before exiting
  if [ -n "$ORIGINAL_DIR" ] && [ "$(pwd)" != "$ORIGINAL_DIR" ]; then
    cd "$ORIGINAL_DIR" || echo "警告: 无法切换回原始目录 '$ORIGINAL_DIR'" >&2
  fi
  exit 1
}


# --- Function: Insert Dependency Line ---
# $1: Full dependency line (e.g., "implementation 'group:artifact:version'")
# $2: Path to the target build file
insert_dependency() {
  local new_dep_line="$1"
  local build_file="$2"
  # Create a secure temporary file
  local temp_file

  # Define error_exit if not defined globally
  error_exit() { echo "ERROR: $1" >&2; exit 1; }

  temp_file=$(mktemp) || error_exit "无法创建临时文件。"
  # Ensure temp file is removed on script exit or error
  # Place trap AFTER temp_file is successfully created
  trap 'rm -f "$temp_file"' EXIT ERR # Added ERR trap for robustness

  echo "  正在注入依赖到 '$build_file': $new_dep_line"

  # awk script with corrected brace placement:
  awk -v new_dep="    $new_dep_line" '
    BEGIN { in_deps = 0; brace_level = 0; inserted = 0; }
    # Match start, handle potential whitespace and comments before {
    /^[ \t]*dependencies[ \t]*\{/ {
        if (brace_level == 0)
        { # MOVED brace to the next line
            # Only trigger on top-level dependencies block
            in_deps = 1;
            # printf("DEBUG: Entered dependencies block at line %d\n", FNR) > "/dev/stderr"; # Debugging
        }
        print $0; # Print the dependencies { line
        # Count all braces on this line to handle cases like dependencies { implementation ... }
        current_line_braces = gsub(/{/, "{") - gsub(/}/, "}");
        brace_level += current_line_braces;
        next;
    }
    # If inside dependencies block, track brace levels
    in_deps {
        # Count braces on the current line
        current_line_braces = gsub(/{/, "{") - gsub(/}/, "}");
        # Look for the closing brace of the block BEFORE decrementing
        # This handles single-line blocks correctly and finds the right spot
        if (brace_level + current_line_braces == 0 && match($0, /}/))
        { # MOVED brace for consistency
            # printf("DEBUG: Found closing brace at line %d, brace_level=%d, current_line_braces=%d\n", FNR, brace_level, current_line_braces) > "/dev/stderr"; # Debugging
            if (!inserted) { # Ensure insertion happens only once per file pass
                 print new_dep; # Print the new dependency *before* the closing brace line
                 inserted = 1;
            }
            in_deps = 0; # We are now effectively outside the block for insertion purposes
        }
        # Update brace level *after* checking the closing condition
        brace_level += current_line_braces;
    }
    # Default action: print the current line
    { print $0 }
    ' "$build_file" >"$temp_file"

  # Check awk exit status
  awk_status=$? # Capture exit status immediately
  if [ $awk_status -ne 0 ]; then
    # Optional: Show awk output/error from temp file if needed for debugging
    # cat "$temp_file" >&2
    error_exit "awk 处理 '$build_file' 失败 (退出码: $awk_status)。"
  fi

  # Check if insertion happened (basic check: temp file size > original)
  # This isn't foolproof but better than nothing. A more robust check is hard.
  # Ensure files exist before checking size
  if [ -f "$build_file" ] && [ -f "$temp_file" ]; then
    original_size=$(wc -c <"$build_file")
    new_size=$(wc -c <"$temp_file")
    # Use -gt for comparison
    if [ "$new_size" -le "$original_size" ]; then
      echo "警告: awk 似乎没有成功将依赖项插入 '$build_file'。可能是 dependencies 块未找到、格式不兼容或依赖已存在。" >&2
      # Optionally, treat this as an error: return 1
    fi
  else
      error_exit "无法比较文件大小，原始文件或临时文件不存在。"
  fi


  # Replace original file
  mv "$temp_file" "$build_file"
  if [ $? -ne 0 ]; then
    # Attempt to restore temp file name for cleanup if move fails
    trap - EXIT ERR # Disable trap briefly to avoid deleting temp on exit
    error_exit "无法用更新后的版本覆盖 '$build_file' (临时文件保留为 '$temp_file')。"
  fi

  echo "  成功更新 '$build_file'."
  # Release trap for this specific temp file as it has been successfully moved
  trap - EXIT ERR # Use - to remove the most recent trap
  return 0
}






# --- Main Script Logic ---

ORIGINAL_DIR=$(pwd)

# 1. Check Arguments
# if [ $# -ne 1 ]; then
#   echo "错误: 需要提供目标 app build 文件的路径作为参数。" >&2
#   usage
# fi
# TARGET_BUILD_FILE="$1"
TARGET_BUILD_FILE="/Users/didi/AndroidStudioProjects/Quattro/quattro/build.gradle"

# 2. Validate Input Files
if [ ! -f "$DEPENDENCY_INPUT_FILE" ]; then
  error_exit "输入依赖文件 '$DEPENDENCY_INPUT_FILE' 未找到。"
fi
if [ ! -f "$TARGET_BUILD_FILE" ]; then
  error_exit "目标 build 文件 '$TARGET_BUILD_FILE' 未找到。"
fi

TARGET_APP_DIR=$(dirname "$TARGET_BUILD_FILE")
if [ ! -d "$TARGET_APP_DIR" ]; then
  error_exit "无法从 '$TARGET_BUILD_FILE' 推断出有效的应用目录。"
fi

echo "开始更新依赖项..."
echo "输入文件: $DEPENDENCY_INPUT_FILE"
echo "目标文件: $TARGET_BUILD_FILE"
echo "应用目录: $TARGET_APP_DIR"
echo "依赖类型: $DEPENDENCY_TYPE"

# 3. Read Input File and Inject Dependencies
# current_group=""
# current_artifact=""
# current_version=""
# processed_count=0
# dependencies_to_add=() # Array to hold dependency strings
#
# while IFS= read -r line || [ -n "$line" ]; do # Process last line if no newline
#   # Trim whitespace (optional but good) and skip comments
#   line=$(echo "$line" | xargs)
#   if [[ "$line" == \#* ]]; then continue; fi
#
#   # Extract Key-Value
#   key="${line%%=*}"
#   value="${line#*=}"
#
#   # Assign values based on key
#   if [[ "$key" == "GROUP" ]]; then
#     current_group="$value"
#   elif [[ "$key" == "ARTIFACT_ID" ]]; then
#     current_artifact="$value"
#   elif [[ "$key" == "VERSION_NAME" ]]; then
#     current_version="$value"
#   fi
#
#   # If line is empty OR we are at the end (checked by loop condition), process block
#   is_separator=false
#   if [[ -z "$line" ]]; then
#     is_separator=true
#   fi
#
#   if ($is_separator || ! IFS= read -r); then 
#     info_msg ">>>>>>>>>>>"+$line
#   fi
#   if ($is_separator || ! IFS= read -r) && ([ -n "$current_group" ] || [ -n "$current_artifact" ] || [ -n "$current_version" ]); then
#     echo "解析块: G=$current_group, A=$current_artifact, V=$current_version"
#     if [ -n "$current_group" ] && [ -n "$current_artifact" ] && [ -n "$current_version" ]; then
#       # Format the dependency string
#       dependency_string="$DEPENDENCY_TYPE '$current_group:$current_artifact:$current_version'"
#       # Add to array for later insertion
#       dependencies_to_add+=("$dependency_string")
#       processed_count=$((processed_count + 1))
#       # Reset for next block
#       current_group=""
#       current_artifact=""
#       current_version=""
#     fi
#   elif $is_separator; then
#     # Reset even if block wasn't complete
#     current_group=""
#     current_artifact=""
#     current_version=""
#   fi
#
# done <"$DEPENDENCY_INPUT_FILE"


























# #!/bin/bash
#
# # --- Configuration ---
# DEPENDENCY_INPUT_FILE="your_dependencies.txt" # Replace with your actual input file
# DEPENDENCY_TYPE="implementation"            # Example dependency type
# # Assuming info_msg is defined elsewhere or replace with echo
# info_msg() { echo "INFO: $1"; }
# error_msg() { echo "ERROR: $1" >&2; }
#
# # --- Input File Check ---
# if [ ! -f "$DEPENDENCY_INPUT_FILE" ]; then
#     error_msg "Input file not found: $DEPENDENCY_INPUT_FILE"
#     exit 1
# fi

# --- Processing Logic ---
current_group=""
current_artifact=""
current_version=""
processed_count=0
dependencies_to_add=() # Array to hold dependency strings
line_num=0

# Function to process the accumulated block
process_accumulated_block() {
    # Check if we have a complete block
    if [ -n "$current_group" ] && [ -n "$current_artifact" ] && [ -n "$current_version" ]; then
        echo "Processing block ending before line $((line_num + 1)): G=$current_group, A=$current_artifact, V=$current_version"
        # Format the dependency string
        local dependency_string="$DEPENDENCY_TYPE '$current_group:$current_artifact:$current_version'"
        # Add to array for later insertion
        dependencies_to_add+=("$dependency_string")
        processed_count=$((processed_count + 1))
    elif [ -n "$current_group" ] || [ -n "$current_artifact" ] || [ -n "$current_version" ]; then
        # Warn if block was incomplete but contained some data
        error_msg "Incomplete block ending before line $((line_num + 1)): G=$current_group, A=$current_artifact, V=$current_version - Skipping."
    fi
    # Reset for the next block (or end of file)
    current_group=""
    current_artifact=""
    current_version=""
}

# --- Main Read Loop ---
# The construct 'while IFS= read -r line || [[ -n "$line" ]]' ensures:
# 1. Reads line by line preserving whitespace (IFS=, -r).
# 2. The loop body executes *one last time* if read fails (EOF)
#    but the variable $line still holds content from the last partial line.
while IFS= read -r line || [[ -n "$line" ]]; do
    line_num=$((line_num + 1))
    # Trim leading/trailing whitespace (using Bash parameter expansion if available - safer than xargs)
    # For older bash or simplicity, stick with xargs or handle potential whitespace issues
    processed_line="${line#"${line%%[![:space:]]*}"}" # Remove leading whitespace
    processed_line="${processed_line%"${processed_line##*[![:space:]]}"}" # Remove trailing whitespace
    # Or using xargs: processed_line=$(echo "$line" | xargs)

    # Check for separator (empty line) or comment
    if [[ -z "$processed_line" || "$processed_line" == \#* ]]; then
        # If we encounter a separator or comment, process the block we *might* have just finished accumulating
        process_accumulated_block
        # If it was a comment, just continue; if empty, we've processed and reset.
        if [[ "$processed_line" == \#* ]]; then
            info_msg "Skipping comment on line $line_num: $processed_line"
        fi
        continue # Move to the next line
    fi

    # --- Extract Key-Value for Data Lines ---
    # Ensure there's an '=' sign before splitting
    if [[ "$processed_line" != *=* ]]; then
        error_msg "Malformed line $line_num (missing '='): $processed_line"
        continue # Skip malformed lines
    fi
    key="${processed_line%%=*}"
    value="${processed_line#*=}"

    # Trim whitespace around key and value if needed (depends on input format strictness)
    # key=$(echo "$key" | xargs)
    # value=$(echo "$value" | xargs)

    # Assign values based on key
    case "$key" in
        "GROUP")
            current_group="$value"
            ;;
        "ARTIFACT_ID")
            current_artifact="$value"
            ;;
        "VERSION_NAME")
            current_version="$value"
            ;;
        *)
            info_msg "Ignoring unknown key '$key' on line $line_num"
            ;;
    esac

done <"$DEPENDENCY_INPUT_FILE"

# # --- Final Processing ---
# # After the loop finishes, process any remaining accumulated data from the last block
# # This covers the case where the file does *not* end with an empty line.
# info_msg "End of file reached. Processing final block if any."
# process_accumulated_block
#
# # --- Output Results ---
# info_msg "Finished processing. Total dependencies added: $processed_count"
# if [ ${#dependencies_to_add[@]} -gt 0 ]; then
#     echo "Dependencies to add:"
#     printf "  %s\n" "${dependencies_to_add[@]}"
#     # Here you would typically inject these into your build file (e.g., build.gradle)
#     # Example: inject_dependencies "${dependencies_to_add[@]}"
# else
#     echo "No valid dependency blocks found to add."
# fi
#
# exit 0





































# Check if any dependencies were found
if [ ${#dependencies_to_add[@]} -eq 0 ]; then
  echo "警告: 在 '$DEPENDENCY_INPUT_FILE' 中未找到有效的依赖块。"
  echo "未修改 '$TARGET_BUILD_FILE'。跳过 Gradle 构建。"
  exit 0 # Exit cleanly, nothing to do
fi

echo "找到 ${#dependencies_to_add[@]} 个依赖项需要添加到 '$TARGET_BUILD_FILE'。"

# Inject all found dependencies one by one
# Doing it sequentially ensures they appear in the order found in the input file
# and reduces complexity compared to one massive awk call.
for dep in "${dependencies_to_add[@]}"; do
  insert_dependency "$dep" "$TARGET_BUILD_FILE"
  # insert_dependency function handles errors and exits if necessary
done

echo "所有依赖项已成功注入 '$TARGET_BUILD_FILE'。"














# # 4. Run Gradle assembleDebug Task
# echo "切换到目标应用目录: $TARGET_APP_DIR"
# cd "$TARGET_APP_DIR" || error_exit "无法切换到目录 '$TARGET_APP_DIR'"
#
# # Determine Gradle command (Assuming wrapper for now)
# gradle_command="./gradlew"
# info_msg "$config_name" "将使用的 Gradle 命令来源: Wrapper ($gradle_command)" # Placeholder config_name
#
# # Check wrapper exists and is executable
# if [ ! -x "$gradle_command" ]; then
#   echo "警告: '$gradle_command' 在 '$TARGET_APP_DIR' 中不存在或不可执行。尝试添加权限..."
#   chmod +x "$gradle_command"
#   if [ $? -ne 0 ]; then
#     error_exit "无法为 '$gradle_command' 添加执行权限。"
#     # error_exit handles cd back if needed
#   fi
# fi
#
# echo "正在运行 Gradle 任务: $gradle_command $GRADLE_TASK"
# "$gradle_command" "$GRADLE_TASK"
# ASSEMBLE_EXIT_CODE=$?
#
# # 5. Return to original directory and report status
# echo "切换回原始目录: $ORIGINAL_DIR"
# cd "$ORIGINAL_DIR" || echo "警告: 无法切换回原始目录 '$ORIGINAL_DIR'" >&2
#
# if [ $ASSEMBLE_EXIT_CODE -ne 0 ]; then
#   error_exit "Gradle 任务 '$GRADLE_TASK' 失败，退出码: $ASSEMBLE_EXIT_CODE。"
# fi
#
# echo "Gradle 任务 '$GRADLE_TASK' 成功完成。"







echo "依赖更新脚本执行完毕！"
exit 0
