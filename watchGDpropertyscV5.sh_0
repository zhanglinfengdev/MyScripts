" 函数：获取当前项目路径并写入文件
function! WriteProjectCwdToFile()
  " 使用 :pwd 命令获取当前目录 (在 IdeaVim 中通常是项目根目录)
  redir => l:pwdOutput
  silent pwd
  redir END
  " 清理输出，获取纯路径
  let l:projectPath = trim(l:pwdOutput)
  " 对路径进行 shell 转义，防止路径中有空格或特殊字符导致问题
  let l:escapedPath = shellescape(l:projectPath)
  " 定义目标文件
  let l:targetFile = '/tmp/yabai_focus_cwd.log'
  " 执行外部 shell 命令，将转义后的路径写入文件
  " 使用 execute 避免映射中的特殊字符问题
  execute ':silent !echo ' . l:escapedPath . ' > ' . shellescape(l:targetFile)
  " (可选) 可以在 IDE 中显示一条消息确认执行
  " echo 'Project CWD written to ' . l:targetFile
endfunction

" 将函数映射到一个快捷键
" 使用一个不太常用的组合键，避免冲突
" 例如：<Leader>yc  (代表 Yabai Cwd) - 假设你的 Leader 键是 \
" 你可以换成其他你喜欢的、不冲突的快捷键
nnoremap <silent> <Leader>yc :call WriteProjectCwdToFile()<CR>

" (备选方案) 如果你想用命令触发，可以定义一个命令
command! ExportProjectCwd call WriteProjectCwdToFile()




yabai -m signal --add event=window_focused label="获取焦点窗口CWD" action="/Users/linfeng/scripts/MyScripts/watchGDpropertyscV5.sh \$YABAI_WINDOW_ID"


解释:
WriteProjectCwdToFile() 函数使用 Vim 的 :pwd 命令，这在 IdeaVim 中通常会返回当前项目的根目录。
redir 用来捕获 :pwd 的输出。
trim() 清除路径前后可能存在的空格。
shellescape() 对路径进行处理，确保在 shell 命令中能被正确识别（例如，包含空格的路径会被引号包起来）。
:silent !echo ... > ... 执行外部 shell 命令，将路径覆盖写入到 /tmp/yabai_focus_cwd.log。
nnoremap <silent> <Leader>yc ... 将这个函数绑定到 Normal 模式下的 <Leader>yc 快捷键。请确保你的 Leader 键已设置（默认为 \），并选择一个不冲突的快捷键。
重要: 修改 .ideavimrc 后，需要重启 Android Studio 或在 Android Studio 内执行 :source ~/.ideavimrc 来使配置生效。
步骤二：修改 get_focused_cwd.sh 脚本

编辑你的 get_focused_cwd.sh 脚本，找到 get_android_studio_cwd() 函数（或者类似的针对 Android Studio 的处理逻辑），将其替换为以下内容：

解释:
get_android_studio_cwd 函数现在使用 osascript。
它首先尝试确保 Android Studio 是最前端的应用。
然后，tell application "System Events" 和 tell process "Android Studio" 指示系统事件将按键发送给 Android Studio 进程。
keystroke 用于模拟按下你在 .ideavimrc 中定义的快捷键 (<Leader>yc)。你需要确保 leader_key_char 和 key_sequence 与你的设置完全匹配。模拟 Leader 键有时需要试验。如果 \ 不行，试试 key code 42 (这是美式键盘 \ 的 key code)。
脚本现在不直接计算或写入 CWD 到 $OUTPUT_FILE。它只是触发 IdeaVim 去做这件事。
增加了错误处理：如果 osascript 执行失败（例如，找不到 Android Studio 进程），它会记录错误并清空 $OUTPUT_FILE，防止下游脚本用到过期的路径。
优势:

准确性: IdeaVim 内部能够准确获取项目根目录。
可靠性: 比 lsof 或猜测方法可靠得多。
集成度: 利用了你已经使用的 IdeaVim 插件。
注意事项与调试:

快捷键冲突: 确保你在 .ideavimrc 中选择的快捷键不会与 Android Studio 或系统快捷键冲突。
Leader 键: 确保你知道你的 Leader 键是什么，并在脚本中正确表示。如果 Leader 键模拟困难，可以考虑在 .ideavimrc 中映射到一个不带 Leader 的、更复杂的组合键（例如 Ctrl+Alt+Shift+Y），然后在 AppleScript 中使用 key code 配合 using {control down, option down, shift down} 来模拟。
AppleScript 权限: 首次运行此脚本触发 Android Studio 时，macOS 可能会弹出权限请求，询问是否允许你的终端（或运行脚本的应用）控制“System Events”或“Android Studio”。你需要授权。检查 系统设置 -> 隐私与安全性 -> 辅助功能，确保你的终端或相关应用有权限。
延迟 (delay): AppleScript 中的 delay 值可能需要根据你的系统速度进行微调。太短可能导致按键发送失败，太长则会感觉卡顿。
测试:
先在 Android Studio 中手动按下你定义的快捷键 (<Leader>yc)，确认 /tmp/yabai_focus_cwd.log 文件被正确创建并写入了项目路径。
然后聚焦到 Android Studio，让 Yabai 自动触发脚本，检查日志 (/tmp/get_focused_cwd.log) 看 osascript 是否成功执行，以及最终的 /tmp/yabai_focus_cwd.log 是否被更新。
这个方法虽然设置起来稍微复杂一点，但一旦成功，就能非常可靠地解决 Android Studio (以及其他基于 IntelliJ 的 IDE，如 IntelliJ IDEA, PyCharm, WebStorm 等，只需在相应 get_X_cwd 函数中修改


#!/bin/bash

# ... (脚本前面的日志函数等保持不变) ...

LOG_FILE="/tmp/get_focused_cwd.log"
OUTPUT_FILE="/tmp/yabai_focus_cwd.log"

# ... (get_kitty_cwd 等其他函数保持不变) ...

# 新的 Android Studio 处理函数
get_android_studio_cwd() {
  local app_pid="$1"
  local window_id="$2" # 可能不需要 window_id 了

  log "Attempting CWD for Android Studio (PID: $app_pid) via IdeaVim shortcut trigger"

  # !! 定义你在 .ideavimrc 中映射的快捷键 !!
  # 假设 Leader 是反斜杠 '\'，快捷键是 yc
  # AppleScript 中表示特殊键需要技巧，用 keystroke 通常更容易
  # 反斜杠需要转义两次：一次为 bash 字符串，一次为 AppleScript 字符串
  local leader_key_char="\\"
  local key_sequence="yc"

  # 使用 osascript 执行 AppleScript 来模拟按键
  osascript -e "
    tell application \"System Events\"
      -- 尝试激活 Android Studio 进程确保按键发送到正确应用
      -- Yabai 可能已经做了，但这层保险更稳妥
      try
        set frontmost of process \"Android Studio\" to true
        delay 0.1 -- 短暂延迟确保窗口激活
      on error errMsg
        log \"AppleScript Error activating Android Studio: ${errMsg}\"
        -- 如果激活失败，可能无法发送按键，记录错误并退出函数
        echo \"\" > \"$OUTPUT_FILE\" # 清空输出文件表示失败
        log \"Clearing output file due to activation failure.\"
        return 1 # 返回错误码
      end try

      -- 告诉特定进程接收按键
      tell process \"Android Studio\"
        -- 发送 Leader 键 (这里假设是反斜杠)
        keystroke \"${leader_key_char}\"
        delay 0.05 -- Leader 后可能需要极短延迟
        -- 发送后续按键
        keystroke \"${key_sequence}\"
      end tell
    end tell
  " >> "$LOG_FILE" 2>&1 # 将 AppleScript 的标准输出和错误都追加到日志

  local osascript_exit_code=$?
  if [[ $osascript_exit_code -eq 0 ]]; then
    log "Successfully triggered IdeaVim shortcut '\${leader_key_char}${key_sequence}' for Android Studio (PID: $app_pid). IdeaVim should now write CWD to $OUTPUT_FILE."
    # 注意：这里脚本 *不再* 尝试确定 CWD 或写入 $OUTPUT_FILE
    # 这个工作已经委托给 IdeaVim 了。
    # 我们甚至可以稍微等待一下，以增加 IdeaVim 完成写入的机会，但这可能不必要
    # sleep 0.1
  else
    log "Error: Failed to trigger IdeaVim shortcut via AppleScript (Exit Code: $osascript_exit_code)."
    # 如果触发失败，最好清空输出文件，避免使用旧的/错误的 CWD
    echo "" > "$OUTPUT_FILE"
    log "Clearing output file due to trigger failure."
  fi

  # 函数现在不直接返回 CWD，只是负责触发
  return $osascript_exit_code
}

# ... (脚本的主逻辑部分，根据 app_name 调用不同的函数) ...

# 主逻辑示例调整：
# ...
elif [[ "$app_name" == "Android Studio" ]]; then
  get_android_studio_cwd "$focused_pid" "$focused_window_id"
  # 注意：这里不再需要检查 get_android_studio_cwd 的返回值来设置 CWD
  # 因为该函数内部失败时会清空 OUTPUT_FILE，成功时由 IdeaVim 写入
  # final_cwd=$(cat "$OUTPUT_FILE") # 可以不读取，让下游脚本读取
else
  # ... (其他应用或通用 lsof 逻辑) ...
fi

# ... (脚本结尾写入 CWD 或日志) ...
# 如果主逻辑依赖 final_cwd 变量，则需要在调用 get_android_studio_cwd 后读取文件：
# final_cwd=$(cat "$OUTPUT_FILE")
# log "Final CWD determined: $final_cwd"
# echo "$final_cwd" > "$OUTPUT_FILE" # 如果上面读取了，这里可能需要再次写入，或者调整逻辑

# 更好的逻辑：让触发脚本只负责触发和记录日志，让下游脚本总是读取 $OUTPUT_FILE
log "Script finished. CWD (if successful) should be in $OUTPUT_FILE"

# --- Script End ---


